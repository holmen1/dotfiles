# XMonad Build Factory

This repository provides a streamlined approach for building and distributing XMonad binaries. The core concept is to separate the build process from deployment, allowing you to compile XMonad once on a dedicated "build machine" and then distribute the binary to other systems.

## Build Once, Deploy Anywhere

This approach offers several advantages:
- **Resource Efficiency**: Only one machine needs the full Haskell development environment
- **Minimal Target Systems**: Target machines only need the binary (~2-4MB), not libraries (~100MB+)
- **Consistent Experience**: Same XMonad version across all your machines
- **Simple Updates**: Rebuild and redistribute only when needed (rarely)


### Features
- **Automated Setup**: The `build-xmonad.sh` script handles cloning repositories, building binaries, and installing dependencies.
- **Customizable Configuration**: Easily create and recompile your `xmonad.hs` configuration file.


---

## Build Machine Setup

### Install Dependencies
```bash
# For Arch-based systems
pacman -S xorg-apps xorg-xmessage libx11 libxft libxinerama libxrandr libxss pkgconf xterm

# For Debian-based systems
apt install libx11-dev libxft-dev libxinerama-dev libxrandr-dev libxss-dev pkg-config xterm
```

### Install Haskell

```bash
# Install GHCup
curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
```

#### Option: Arch Linux (Recommended for Arch systems)

Note: [Static linking](https://wiki.archlinux.org/title/Haskell#Static_linking)

Instead of GHCup, you can use Pacman to install pre-built Haskell tools:

```bash
# Install GHC and Cabal from official Arch repositories
pacman -S ghc-static cabal-install
```

**Advantages:**
- No need to manage a separate Haskell installer
- XMonad builds fine without additional setup

**Known Limitations:**
- HLS (Haskell Language Server) may not align properly with LSP in Neovim
- Confirm [version-support](https://haskell-language-server.readthedocs.io/en/latest/support/ghc-version-support.html)

### Config cabal
Create cabal.project file
```
cat > cabal.project <<EOF
packages: ./xmonad ./xmonad-contrib
EOF
```

### Build
```
$ ./build-xmonad.hs
```
**Role of build-xmonad.sh**
The build-xmonad.sh script automates the process of setting up and building xmonad

1. **Clone or Update Repositories**:
   - Clones the xmonad and xmonad-contrib repositories from GitHub if they don't already exist.
   - Updates the repositories if they are already cloned.

2. **Copies Your Configuration**:
   - Takes your custom `xmonad.hs` from the specified location
   - Creates a Cabal project that includes your configuration

3. **Builds a Self-Contained Binary**:
   - Compiles your configuration directly into the binary
   - No need for a separate configuration file on target machines
   - Creates a binary at `$BUILD_DIR/bin/`

```bash
# Create a distributable archive
tar -czvf xmonad-binary.tar.gz -C ~/.local/bin xmonad
```

## Target Machine Setup

Target machines only need X11 libraries, not Haskell:

```bash
# For Arch-based systems
pacman -S libx11 libxft libxinerama libxrandr libxss xterm

# For Debian-based systems
apt install libx11-6 libxft2 libxinerama1 libxrandr2 libxss1 xterm
```

### Configuration on Build Machine

1. Create configuration directory:
```bash
mkdir -p ~/.config/xmonad
```

2. Create a minimal xmonad.hs for debugging:
```bash
echo 'import XMonad

main :: IO ()
main = xmonad def' > ~/.config/xmonad/xmonad.hs
```
When ok, switch to ```~/repos/dotfiles/dotfiles/xmonad/xmonad.hs```

3. Set up .xinitrc:
```bash
echo 'exec xmonad' >> ~/.xinitrc
```

### Recompilation when debugging
Whenever you update `xmonad.hs`, recompile it with:

```bash
xmonad --recompile
xmonad --restart
```

### Binary Installation on Target Machines

Since we never recompile on target machines, installation is simple:

```bash
# Extract and install binary
tar -xzf xmonad-v0.18.0.tar.gz
sudo mkdir -p /opt/xmonad
sudo cp xmonad-v0.18.0 /opt/xmonad/
sudo chmod +x /opt/xmonad/xmonad-v0.18.0

# Create symlink
sudo ln -sf /opt/xmonad/xmonad-v0.18.0 /usr/local/bin/xmonad
``

## Important Note on Recompilation

**The target machines cannot recompile your xmonad.hs without installing the libraries.**

If you need to modify xmonad.hs on target machines:
1. Copy it back to your build machine
2. Make changes there
3. Recompile
4. Redistribute the binary

This trade-off of flexibility for size and simplicity is the core of the "build factory" approach.

---
## Lessons Learned

**Note on Binary Locations**

- Original installation: `~/.local/bin/xmonad`
- Recompiled configuration: `~/.cache/xmonad/xmonad-x86_64-linux`

XMonad automatically uses the newer cache version when available.

**GHC environment file**
(`.ghc.environment.x86_64-linux-9.4.8`). This file is automatically generated by `cabal` when you use the `--package-env` option, and it defines the package environment for GHC (the Haskell compiler)

**Xmonad the Default Configuration**
- **Mod Key**: The `Alt` key (`mod1Mask`) is used as the modifier key
- **Terminal**: Defaults to `xterm`
- **Key Bindings**:
  - `Mod + Shift + Enter`: Launches the terminal
  - `Mod + Shift + C`: Closes the focused window
  - `Mod + Space`: Switches between layouts
  - `Mod + Tab`: Cycles through windows
  - `Mod + Q`: Restarts xmonad



# Examining XMonad Binaries to Understand Size Differences


## Basic Analysis

```bash
# Compare file types
file ~/.local/bin/xmonad
file ~/.cache/xmonad/xmonad-x86_64-linux

# See what libraries they depend on
ldd ~/.local/bin/xmonad
ldd ~/.cache/xmonad/xmonad-x86_64-linux

# Check section sizes
size ~/.local/bin/xmonad
size ~/.cache/xmonad/xmonad-x86_64-linux
```

## Looking at Debug Symbols

```bash
# Count symbols in each binary
nm ~/.local/bin/xmonad | wc -l
nm ~/.cache/xmonad/xmonad-x86_64-linux | wc -l

# Create a stripped copy to see impact of debug symbols
cp ~/.cache/xmonad/xmonad-x86_64-linux /tmp/xmonad-stripped
strip /tmp/xmonad-stripped
ls -la /tmp/xmonad-stripped
```

## Deeper Analysis

```bash
# Examine section headers
readelf -S ~/.local/bin/xmonad | grep -A2 "\[.*\] \."
readelf -S ~/.cache/xmonad/xmonad-x86_64-linux | grep -A2 "\[.*\] \."

# Check compilation flags (might show optimization level)
readelf -p .comment ~/.local/bin/xmonad
readelf -p .comment ~/.cache/xmonad/xmonad-x86_64-linux
```

These commands will help you understand:
1. Whether debug symbols are present (explaining larger size)
2. Which optimization levels were used 
3. Whether static vs dynamic linking differs
4. Which sections contribute to size differences

The cache binary is likely larger because it contains debug information to help with error reporting during development, whereas the installed binary may be optimized for size and performance.
